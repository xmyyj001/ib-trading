# /home/app/lib/trading.py

from ib_insync import Contract, Stock, Forex, Future, Option, Order, TagValue
from lib.environment import Environment
import asyncio

class Instrument:
    """
    A wrapper for ib_insync contract objects.
    This class should not be instantiated directly. Use subclasses like Stock, Forex.
    """
    IB_CLS = None  # Subclasses must override this

    def __init__(self, env: Environment, ib_contract: Contract = None, **kwargs):
        if self.IB_CLS is None and not ib_contract:
            raise TypeError("Cannot instantiate the base Instrument class directly. Use a subclass like Stock or Forex.")
        
        self._env = env  # <-- Dependency Injection
        
        if ib_contract and isinstance(ib_contract, Contract):
            self.contract = ib_contract
        elif kwargs:
            if self.IB_CLS is None:
                 raise TypeError(f"IB_CLS is not defined for class {self.__class__.__name__}")
            self.contract = self.IB_CLS(**kwargs)
        else:
            raise ValueError("Instrument must be initialized with a contract object or kwargs.")

    async def get_contract_details_async(self):
        if not self.contract.conId:
            try:
                await self._env.ibgw.qualifyContractsAsync(self.contract)
            except Exception as e:
                self._env.logging.error(f"Error qualifying contract {self.contract.symbol}: {e}")

class Stock(Instrument):
    IB_CLS = Stock
class Forex(Instrument):
    IB_CLS = Forex
class Future(Instrument):
    IB_CLS = Future
class Option(Instrument):
    IB_CLS = Option

class Trade:
    def __init__(self, env: Environment, strategies):
        self._env = env # <-- Dependency Injection
        self._strategies = strategies
        self.trades = {}

    def consolidate_trades(self):
        for strategy in self._strategies:
            if not hasattr(strategy, '_signals') or not strategy._signals:
                continue
            for conId, (weight, price) in strategy._signals.items():
                if conId not in self.trades:
                    if conId not in strategy._contracts:
                        continue
                    self.trades[conId] = {'quantity': 0, 'contract': strategy._contracts[conId].contract}
                if price > 0:
                    self.trades[conId]['quantity'] += int(strategy._exposure * weight / price)

    async def place_orders_async(self, OrderClass, order_params={}, order_properties={}):
        if not self.trades:
            return []
        orders = []
        for conId, trade_info in self.trades.items():
            action = 'BUY' if trade_info['quantity'] > 0 else 'SELL'
            quantity = abs(trade_info['quantity'])
            if quantity == 0:
                continue
            order = OrderClass(action, quantity, **order_params)
            for prop, value in order_properties.items():
                setattr(order, prop, value)

            trade = self._env.ibgw.placeOrder(trade_info['contract'], order)
            
            if trade:
                await self._env.ibgw.sleep(0)
                orders.append({
                    'orderId': trade.order.orderId,
                    'symbol': trade.contract.symbol,
                    'action': trade.order.action,
                    'quantity': trade.order.totalQuantity,
                    'status': trade.orderStatus.status
                })
        return orders
