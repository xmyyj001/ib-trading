# ===================================================================
# == FINAL ARCHITECTURE v3: main.py
# == Moves Queue creation into the background thread to resolve final loop conflict.
# ===================================================================

import asyncio
from contextlib import asynccontextmanager
from datetime import datetime
import json
import logging
from os import environ
from fastapi import FastAPI, Request, Response
import threading
import uuid

from intents.allocation import Allocation
from intents.cash_balancer import CashBalancer
from intents.close_all import CloseAll
from intents.collect_market_data import CollectMarketData
from intents.intent import Intent
from intents.summary import Summary
from intents.trade_reconciliation import TradeReconciliation
from intents.reconcile import Reconcile
from strategies.test_signal_generator import TestSignalGenerator
from lib.environment import Environment

def ib_thread_loop(app_state, loop: asyncio.AbstractEventLoop):
    asyncio.set_event_loop(loop)
    
    # --- FINAL FIX: Create queue and results dict INSIDE the new loop's context ---
    app_state.request_queue = asyncio.Queue(maxsize=1)
    app_state.results = {}
    
    env = app_state.env

    async def connect_with_retries():
        """An infinitely retrying connection function."""
        while True:
            try:
                logging.info("IB Thread: Attempting to connect...")
                await asyncio.wait_for(env.ibgw.connectAsync(
                    host='127.0.0.1', port=4002, clientId=1), timeout=20.0)
                
                if env.ibgw.isConnected():
                    logging.info("IB Thread: Successfully connected to IB Gateway.")
                    return
            except Exception as e:
                logging.warning(f"IB Thread: Connection attempt failed: {e}. Retrying in 30 seconds...")
                await asyncio.sleep(30)

    async def main_async_logic():
        try:
            await connect_with_retries()

            while True:
                request_id, intent_class, body = await app_state.request_queue.get()
                logging.info(f"IB Thread: Received request {request_id} for intent {intent_class.__name__}")
                result_data, error_str = {}, None
                try:
                    intent_instance = intent_class(env=env, **body)
                    result_data = await intent_instance.run()
                except Exception as e:
                    logging.error(f"IB Thread: Error running intent: {e}", exc_info=True)
                    error_str = f'{e.__class__.__name__}: {e}'
                
                app_state.results[request_id] = (result_data, error_str)
                app_state.request_queue.task_done()

        except Exception as e:
            logging.critical(f"IB Thread: A critical error occurred: {e}", exc_info=True)
        finally:
            if env.ibgw.isConnected():
                env.ibgw.disconnect()
            logging.info("IB Thread: Shutting down.")

    loop.run_until_complete(main_async_logic())

@asynccontextmanager
async def lifespan(app: FastAPI):
    logging.info("Lifespan: Startup - Initializing application...")
    app.state.env = Environment()
    
    ib_loop = asyncio.new_event_loop()
    thread = threading.Thread(target=ib_thread_loop, args=(app.state, ib_loop), daemon=True)
    thread.start()
    logging.info("Lifespan: IB background thread started.")
    yield
    logging.info("Lifespan: Shutdown.")

logging.basicConfig(level=logging.INFO)
app = FastAPI(lifespan=lifespan)

INTENTS = {
    'allocation': Allocation,
    'cash-balancer': CashBalancer,
    'close-all': CloseAll,
    'collect-market-data': CollectMarketData,
    'summary': Summary,
    'trade-reconciliation': TradeReconciliation,
    'reconcile': Reconcile,
    'testsignalgenerator': TestSignalGenerator
}

@app.get("/{intent}")
@app.post("/{intent}")
async def handle_intent(intent: str, request: Request):
    body = {}
    if request.method == 'POST' and request.headers.get('content-length'):
        try:
            body = await request.json()
        except json.JSONDecodeError:
            return Response(content=json.dumps({"error": "Invalid JSON body"}), media_type="application/json", status_code=400)

    if intent not in INTENTS:
        raise ValueError(f"Unknown intent received: {intent}")

    request_id = str(uuid.uuid4())
    
    try:
        logging.info(f"Main Thread: Placing request {request_id} in queue...")
        await asyncio.wait_for(request.app.state.request_queue.put((request_id, INTENTS[intent], body)), timeout=5.0)
    except asyncio.TimeoutError:
        logging.error("Main Thread: Timed out waiting to place request in queue. The worker might be busy.")
        return Response(content=json.dumps({"error": "Service is busy, please try again later."}, status_code=503))

    result_data, error_str = {}, None
    results = request.app.state.results
    for _ in range(600): # 60s timeout
        if request_id in results:
            result_data, error_str = results.pop(request_id)
            break
        await asyncio.sleep(0.1)
    else:
        error_str = "Request timed out waiting for a response from the IB worker thread."
        logging.error(f"Main Thread: {error_str} (Request ID: {request_id})")

    if error_str:
        result = {'error': error_str}
        status_code = 500
    else:
        result = result_data
        status_code = 200

    result['utcTimestamp'] = datetime.utcnow().isoformat()
    return Response(
        content=json.dumps(result, default=str) + '\n',
        media_type="application/json",
        status_code=status_code
    )